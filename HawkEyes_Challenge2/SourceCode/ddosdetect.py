import os
import sys
import dpkt
import numpy as np
from keras.preprocessing import sequence
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM
from keras.preprocessing import sequence

from keras.optimizers import Adam
from keras.models import load_model
from keras.callbacks import ModelCheckpoint

def GetDataPcap(pcap):
    sequences = list()
    col = list()
    prevTime = 0
    curTime = 0
    flag = 0
    counter = 0
    tcpcounter = 0
    udpcounter = 0
    # icmpcounter = 0
    tcpSync = 0
    tcpAck = 0
    for (ts, buf) in pcap:
        try:

            if (flag == 0):
                flag = 1
                prevTime = int(ts)
            currTime = int(ts)
            if ((currTime - prevTime) >= 1):
                col.append(counter)
                col.append(tcpcounter)
                col.append(udpcounter)
                # col.append(icmpcounter)
                col.append(tcpSync)
                col.append(tcpAck)
                counter = 0
                tcpcounter = 0
                udpcounter = 0
                # icmpcounter = 0
                tcpSync = 0
                tcpAck = 0
                sequences.append(col)
                col = list()

                for i in range(0, currTime - prevTime - 1):
                    sequences.append([0, 0, 0, 0, 0])
                prevTime = currTime

            counter += 1
            eth = dpkt.ethernet.Ethernet(buf)

            ip = eth.data

            if ip.p == dpkt.ip.IP_PROTO_TCP:
                tcpcounter += 1
                tcp = ip.data
                if ((tcp.flags & dpkt.tcp.TH_SYN) and not (tcp.flags & dpkt.tcp.TH_ACK)):
                    tcpSync += 1

                if ((tcp.flags & dpkt.tcp.TH_SYN) and (tcp.flags & dpkt.tcp.TH_ACK)):
                    tcpAck += 1

            if ip.p == dpkt.ip.IP_PROTO_UDP:
                udpcounter += 1

            # if ip.p == dpkt.ip.IP_PROTO_ICMP:
            #     icmpcounter += 1


        except:
            pass
    col.append(counter)
    col.append(tcpcounter)
    col.append(udpcounter)
    # col.append(icmpcounter)
    col.append(tcpSync)
    col.append(tcpAck)
    sequences.append(col)
    return sequences

def DdosDetection(file_path):
    X = list()
    f = open(file_path, 'rb')
    pcap = dpkt.pcap.Reader(f)
    X.append(GetDataPcap(pcap))
    to_pad = 15000
    new_seq = []
    for one_seq in X:
        len_one_seq = len(one_seq)
        last_val = one_seq[-1]
        n = to_pad - len_one_seq
        if (n > 0):
            to_concat = np.repeat([0, 0, 0, 0, 0], n).reshape(5, n).transpose()
            new_one_seq = np.concatenate([one_seq, to_concat])
            new_seq.append(new_one_seq)
        else:
            new_seq.append(one_seq[:15000])
    final_seq1 = np.stack(new_seq)

    seq_len = 30
    final_seq = sequence.pad_sequences(final_seq1, maxlen=seq_len, padding='post', dtype='int', truncating='post')
    pred_Y = model.predict_classes(final_seq)
    return pred_Y

def load_trained_model():
    global model
    model = Sequential()
    model.add(LSTM(256, return_sequences=True, input_shape=(30, 5)))
    model.add(LSTM(32, input_shape=(30, 256)))
    model.add(Dense(1, activation='sigmoid'))
    model.load_weights('trained_model.hdf5')

# Defining main function
def main():
    # total arguments
    n = len(sys.argv)
    if n == 2:
        # Arguments passed
        print("\nFull Path Pcap file: ", sys.argv[1])
    elif n > 2:
        print("Extra arguments provided")
    else:
        print("Provide the full path to Pcap file")

    if not os.access(os.path.dirname(sys.argv[1]), os.R_OK):
        print("file does not exists ")
        exit()

    load_trained_model()
    y = DdosDetection(sys.argv[1])
    with open('output.txt','w') as out:
        if(y==1):
            out.write("Malicious")
        else:
            out.write("Benign")


if __name__ == "__main__":
    main()