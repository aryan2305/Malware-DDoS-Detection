import dpkt
import socket

import pandas as pd
import numpy as np

from keras.preprocessing import sequence
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

from keras.optimizers import Adam
from keras.models import load_model
from keras.callbacks import ModelCheckpoint

# def GetDataPcap(pcap):
#     sequences = list()
#     col = list()
#     prevTime = 0
#     curTime = 0
#     flag = 0
#     counter = 0
#     tcpcounter = 0
#     udpcounter = 0
#     icmpcounter = 0
#     tcpSync = 0
#     tcpAck = 0
#     for (ts,buf) in pcap:
#         try:
#
#             if(flag==0):
#                 flag = 1
#                 prevTime = int(ts)
#             currTime = int(ts)
#             if((currTime-prevTime)>=1):
#                 col.append(counter)
#                 col.append(tcpcounter)
#                 col.append(udpcounter)
#                 col.append(icmpcounter)
#                 col.append(tcpSync)
#                 col.append(tcpAck)
#                 counter = 0
#                 tcpcounter = 0
#                 udpcounter = 0
#                 icmpcounter = 0
#                 tcpSync = 0
#                 tcpAck = 0
#                 sequences.append(col)
#                 col = list()
#
#                 for i in range(0,currTime-prevTime-1):
#                     sequences.append([0,0,0,0,0,0])
#                 prevTime = currTime
#
#
#
#             counter+=1
#             eth = dpkt.ethernet.Ethernet(buf)
#
#             ip=eth.data
#
#             if ip.p==dpkt.ip.IP_PROTO_TCP:
#                 tcpcounter+=1
#                 tcp = ip.data
#                 if ((tcp.flags & dpkt.tcp.TH_SYN) and not (tcp.flags & dpkt.tcp.TH_ACK)):
#                     tcpSync +=1
#
#                 if ((tcp.flags & dpkt.tcp.TH_SYN) and (tcp.flags & dpkt.tcp.TH_ACK)):
#                     tcpAck +=1
#
#             if ip.p==dpkt.ip.IP_PROTO_UDP:
#                 udpcounter+=1
#
#             if ip.p==dpkt.ip.IP_PROTO_ICMP:
#                 icmpcounter+=1
#
#
#         except:
#             pass
#     col.append(counter)
#     col.append(tcpcounter)
#     col.append(udpcounter)
#     col.append(icmpcounter)
#     col.append(tcpSync)
#     col.append(tcpAck)
#     sequences.append(col)
#     return sequences

# path = '/content/Ddos/Ddos_Detection_Dataset/'
# sequences = list()
# targets = list()
#
# for i in range(1,7):
#     file_path = path +'Ddos_benign/benign1/' + str(i) + '.pcap'
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(0)
#
# for i in range(1,18):
#     file_path = path +'Ddos_benign/benign2/' + str(i) + '.pcap'
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(0)
#
# for i in range(1,18):
#     file_path = path +'Ddos_benign/benign3/' + str(i) + '.pcap'
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(0)
#
# for i in range(1,18):
#     file_path = path +'Ddos_benign/p2pbox1/' + str(i) + '.pcap'
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(0)
#
# for i in range(1,9):
#     file_path = path +'Ddos_Attack_data/00' + str(i)
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(1)
#
# for i in range(10,87):
#     file_path = path +'Ddos_Attack_data/0' + str(i)
#     f = open(file_path,'rb')
#     pcap = dpkt.pcap.Reader(f)
#     sequences.append(GetDataPcap(pcap))
#     targets.append(1)

import pickle

with open('Features', 'rb') as fp:
    sequences = pickle.load(fp)
with open('Labels', 'rb') as fp:
    targets = pickle.load(fp)

final_seq = sequences

len_of_parts = 60

train = []
test = []
train_target = []
test_target = []
for i in range(len(final_seq)):
    if i % 4 == 0:
        test.append(final_seq[i])
        test_target.append(targets[i])
    else:
        length = len(final_seq[i])
        for j in range(0, ((length + len_of_parts - 1) // len_of_parts)):
            if j == ((length + len_of_parts - 1) // len_of_parts) - 1:
                if length % len_of_parts != 0:
                    temp = final_seq[i][j * len_of_parts:]
                    for k in range(0, len_of_parts - (length % len_of_parts)):
                        temp.append([0, 0, 0, 0, 0, 0])
                    train.append(temp)
                    train_target.append(targets[i])
                    continue
            
            train.append(final_seq[i][j * len_of_parts: (j + 1) * len_of_parts])
            train_target.append(targets[i])

from keras.preprocessing import sequence

seq_len = len_of_parts
train = sequence.pad_sequences(train, maxlen=seq_len, padding='post', dtype='int', truncating='post')

train = np.array(train)
test = np.array(test)
train_target = np.array(train_target)
test_target = np.array(test_target)

model = Sequential()
model.add(LSTM(256, return_sequences=True, input_shape=(seq_len, 6)))
model.add(LSTM(32, input_shape=(seq_len, 256)))
model.add(Dense(1, activation='sigmoid'))

adam = Adam(lr=0.001)
model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['accuracy'])
model.fit(train, train_target, epochs=30, batch_size=128)

from sklearn.metrics import accuracy_score

# test and test_target

test_preds = []
for i in range(0, len(test)):
    length = len(test[i])
    test_input = []
    for j in range(0, ((length + len_of_parts - 1) // len_of_parts)):
        if j == ((length + len_of_parts - 1) // len_of_parts) - 1:
            if length % len_of_parts != 0:
                temp = test[i][j * len_of_parts:]
                for k in range(0, len_of_parts - (length % len_of_parts)):
                    temp.append([0, 0, 0, 0, 0, 0])
                test_input.append(temp)
                continue
        test_input.append(test[i][j * len_of_parts: (j + 1) * len_of_parts])
    
    test_pred_single = model.predict_classes(test_input)
    flag = 0
    for a in test_pred_single:
        if a == 1:
            flag = 1
            break
    test_preds.append(flag)
accuracy_score(test_target, test_preds)

model.save("my_model.h5")
