import dpkt

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
# %matplotlib inline
import matplotlib.pyplot as plt
from os import listdir

from keras.preprocessing import sequence
import tensorflow as tf
from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

from keras.optimizers import Adam
from keras.models import load_model
from keras.callbacks import ModelCheckpoint

def GetDataPcap(pcap):
    sequences = list()
    col = list()
    prevTime = 0
    curTime = 0
    flag = 0
    counter = 0
    tcpcounter = 0
    udpcounter = 0
    icmpcounter = 0
    tcpSync = 0
    tcpAck = 0
    for (ts,buf) in pcap:
        try:
            
            if(flag==0):
                flag = 1
                prevTime = int(ts)
            currTime = int(ts)
            if((currTime-prevTime)>=1):
                col.append(counter)
                col.append(tcpcounter)
                col.append(udpcounter)
                col.append(icmpcounter)
                col.append(tcpSync)
                col.append(tcpAck)
                counter = 0
                tcpcounter = 0
                udpcounter = 0
                icmpcounter = 0
                tcpSync = 0
                tcpAck = 0
                sequences.append(col)
                col = list()
                
                for i in range(0,currTime-prevTime-1):
                    sequences.append([0,0,0,0,0])
                prevTime = currTime
                
            
               
            counter+=1    
            eth = dpkt.ethernet.Ethernet(buf)

            ip=eth.data

            if ip.p==dpkt.ip.IP_PROTO_TCP: 
                tcpcounter+=1
                tcp = ip.data
                if ((tcp.flags & dpkt.tcp.TH_SYN) and not (tcp.flags & dpkt.tcp.TH_ACK)):
                    tcpSync +=1
                
                if ((tcp.flags & dpkt.tcp.TH_SYN) and (tcp.flags & dpkt.tcp.TH_ACK)):
                    tcpAck +=1

            if ip.p==dpkt.ip.IP_PROTO_UDP:
                udpcounter+=1
            
            if ip.p==dpkt.ip.IP_PROTO_ICMP:
                icmpcounter+=1
            
            
        except:
            pass
    col.append(counter)
    col.append(tcpcounter)
    col.append(udpcounter)
    col.append(icmpcounter)
    col.append(tcpSync)
    col.append(tcpAck)
    sequences.append(col)
    return sequences


# Path is hardcoded
path = '/content/Ddos/Ddos_Detection_Dataset/'
sequences = list()
targets = list()

for i in range(1,7):
    file_path = path +'Ddos_benign/benign1/' + str(i) + '.pcap'
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(0)

for i in range(1,18):
    file_path = path +'Ddos_benign/benign2/' + str(i) + '.pcap'
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(0)

for i in range(1,18):
    file_path = path +'Ddos_benign/benign3/' + str(i) + '.pcap'
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(0)

for i in range(1,18):
    file_path = path +'Ddos_benign/p2pbox1/' + str(i) + '.pcap'
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(0)
    
for i in range(1,9):
    file_path = path +'Ddos_Attack_data/00' + str(i)
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(1)

for i in range(10,87):
    file_path = path +'Ddos_Attack_data/0' + str(i)
    f = open(file_path,'rb')
    pcap = dpkt.pcap.Reader(f)
    sequences.append(GetDataPcap(pcap))
    targets.append(1)

import pickle

with open('Sequence1', 'wb') as fp:
    pickle.dump(sequences, fp)

with open('Target1', 'wb') as fp:
    pickle.dump(targets, fp)

print(targets)
print(sequences[0])

len_sequences = []
for one_seq in sequences:
    len_sequences.append(len(one_seq))
pd.Series(len_sequences).describe()

#Padding the sequence with the values in last row to max length
to_pad = 15000
new_seq = []
for one_seq in sequences:
    len_one_seq = len(one_seq)
    last_val = one_seq[-1]
    n = to_pad - len_one_seq
    if(n>0):
        to_concat = np.repeat([0,0,0,0,0], n).reshape(5, n).transpose()
        new_one_seq = np.concatenate([one_seq, to_concat])
        new_seq.append(new_one_seq)
    else:
        new_seq.append(one_seq[:15000])
final_seq1 = np.stack(new_seq)

#truncate the sequence to length 30
from keras.preprocessing import sequence
seq_len = 30
final_seq=sequence.pad_sequences(final_seq1, maxlen=seq_len, padding='post', dtype='int', truncating='post')

train = []
test = []
train_target = []
test_target = []
for i in range(len(final_seq)):
    if(i%4==0):
        test.append(final_seq[i])
        test_target.append(targets[i])
    else:
        train.append(final_seq[i])
        train_target.append(targets[i])

train = np.array(train)
test = np.array(test)
train_target = np.array(train_target)
test_target = np.array(test_target)

model = Sequential()
model.add(LSTM(256, return_sequences=True, input_shape=(seq_len, 5)))
model.add(LSTM(32, input_shape=(seq_len, 256)))
model.add(Dense(1, activation='sigmoid'))

adam = Adam(lr=0.001)
checkpoint = ModelCheckpoint("best_model.hdf5", monitor='loss', verbose=1,save_best_only=True, mode='auto', save_freq=1)
model.compile(loss='binary_crossentropy', optimizer=adam, metrics=['accuracy'])
model.fit(train, train_target, epochs=100, batch_size=128,callbacks=[checkpoint])

from sklearn.metrics import accuracy_score
test_preds = model.predict_classes(test)
accuracy_score(test_target, test_preds)